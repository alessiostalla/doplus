# The doplus (do+) Manual #

## Table of Contents ##



## Overview ##

do+ is a high-level, extensible general iteration construct for Common Lisp.

do+, like DO and unlike both LOOP and iterate, distinguishes between a "head" containing the clauses that control various aspects of the iteration (which variables are bound, how they are updated, when the loop stops, etc.), and a body, consisting of user code that is executed on each iteration and that can make use of certain specific operators provided by do+.

In other words, the signature of do+ is

**do+** (_clause`*`_) **&body** _body_

**Clauses are macros**. The names of built-in clauses, used throughout this document, are symbols in the **doplus** package; user-defined clauses can be defined in other packages as well.

## Types of iteration clauses ##

doplus accepts the following types of simple clauses:

  * **binding** - specifies a variable to be bound during the loop.
  * **declaration** - inserts a declaration at the beginning of the loop body.
  * **initialization** - specifies a form to be evaluated before the first iteration.
  * **step** - specifies a form to be evaluated at the end of each iteration. Multiple initialization or step clauses will have their forms executed in order.
  * **termination** - specifies a condition for terminating the loop, that is a form which is evaluated on each iteration and, if it returns true, causes the loop to stop. Multiple termination clauses are combined by OR.
  * **result form** - specifies a value to be returned as the value of the do+ expression when the iteration ends. Multiple result forms are combined to multiple return values.
  * **finalization** - specifies a form to be evaluated after the last iteration, with loop bindings still in scope. Multiple finalization clauses will have their forms executed in order.
  * **accumulation** - detailed below.
  * **prologue**, **epilogue** - forms to be executed respectively before and after the loop body, on each iteration. These are typically only generated by other complex clauses.
  * **options** - a special clause to control certain advanced aspects of the behaviour of the do+ macro.

**Accumulation** deserves a section by itself. An **accumulation** clause defines a strategy for collecting values into a single result object; in particular, the strategy consists of:
  * a variable, bound during the lifetime of the loop;
  * a function of two arguments, the current value of the variable and the accumulator, which is used to calculate the next value of the accumulator.

Accumulation clauses are a low-level building block; in user code, they are generally created by higher-level clauses, along with:
  * an init form, the initial value of the accumulation variable;
  * a result processor, a function to be applied to the accumulator at the end of the loop.

The canonical example, corresponding to :collect ... :to `x` in LOOP, is represented by an accumulation clause with `x` as the variable, **cons** as the function, a `NIL` init form, and **nreverse** as the result processor.

### Composite clauses ###

Additionally, there are two composite clause types that combine multiple simple clauses, adding extra semantics:

  * **iteration** - a combination of a number of binding, initialization and step forms, some of which can play the special role of pre or post conditions (i.e. they are evaluated right before/after proper init/step forms and, if they return false, cause the termination of the loop). Some examples of high-level clauses that produce **iteration** clauses: `(for x (in '(a b c d)))`, `(for k (from 0 :to 10))`. Strictly speaking, the clauses that compose an iteration need not to be related, although it's generally meaningful that they are. As a special case, a **simple iteration** is an iteration clause with a single variable and with at most one init, step, pre and post condition form, and those forms are related to that variable. Such a distinction is only important at the implementation level, not at the user level - if you're not extending doplus, you can safely ignore it.
  * **generator** - lazy **iteration**: do+ won't automatically update the iteration variables at the end of each loop; instead, the user can invoke a macro - (**update** _generator-name_) - to explicitly perform the update (including checking pre and post conditions and terminating the loop if they're not met). **Note:** generators are **always** initialized eagerly. This is different from iterate where you have to call update to compute even the initial value of the generator.

## Built-in clauses ##

The user interface of do+ consists of macros that generate one or more instances of the clause types discussed in the previous section. Multiple clauses can be combined in a list.

Here is a list of the clause macros currently supported by do+:

### Iteration ###
  * **for** _var_ _for-body_ general iteration clause. _for-body_ is a Lisp expression generating a doplus clause. _var_ is a generally a symbol, but certain body forms support destructuring; in those cases, _var_ can be a lambda list as well (as supported by destructuring-bind). The following built-in macros are designed to work with **for**:
    * **in** _seq_ **&rest** _args_ - _var_ is set to each element of the sequence on each iteration, and the loop stops when the sequence ends. On implementations with extensible sequences (ABCL and SBCL), a native sequence iterator is used, and thus user-defined sequence types are supported. On other implementations, specialized iterators for lists or vectors are used. Any provided _args_ are passed directly to **make-sequence-iterator** (refer to the extensible sequences iterator API). **in** supports destructuring.
    * **in-list** _list_ **&key** _by_ _rest_ - iterates over a list, assigning the iteration variable(s) the result of destructuring each car in turn. If _rest_ is provided, it must name a variable to which the remaining cdr of the list will be assigned on each iteration. If _by_ is provided, it must be a function that, given the current list, returns the next cdr to process.
    * **in-vector** _vector_ **&key** _index_ - iterates over a vector. _index_, if provided, is assigned the current index in the vector.
    * **across** - synonym to **in-vector**.
    * **from** _expr_ **&key** _to_ _by_ _using_ _while_ - _var_ is initially set to expr, then incremented by _by_ on each iteration. The loop stops when _var_ reaches or surpasses _to_. _using_ and _while_ control what "incremented by" and "reaches or surpasses" mean: _using_ is the function used to increment _var_, by default +. _while_ is a function of two arguments, applied the current value of _var_ and the value of _to_: when it returns false, the loop stops. By default, _while_ is equivalent to <= (when from <= to) or >= (when from >= to).
    * **to** _expr_ **&key** _from_ _by_ _using_ _while_ - alternate syntax for **from**, by default starting from 0.
    * **hash-entries-of** _hash-table_ - iterates over the entries of a hash table. _var_ must be in the form (_key_ _value_).
    * **symbols-in** _package-or-packages_ **&rest** _symbol-types_ - iterates over the symbols in one or more packages. _symbol-types_ must be at least one of **:external**, **:internal**, **:inherited**, as per the specification of **with-package-iterator**.
    * **optimizing** _expr_ **&key** _test_ _saving_ _in_ - finds the optimum value of an expression, testing by default with #'>. **optimizing** evaluates _expr_ on each iteration. Every time the value of _expr_ is greater than the one calculated the iteration before, _var_ is set to the current value of _expr_. Additionally, if _saving_ and _in_ are provided, each variable specified in _saving_ is stored to the corresponding variable in _in_. _saving_ and _in_ can be either a symbol, or lists of symbols of the same length. Example: (**for** length-of-longest-x (**optimizing** (length x) **:saving** x **:in** longest-x)).
    * **maximizing** is a synonym for **optimizing**.
    * **minimizing** is a synonym for **optimizing** except that the default test is #'< rather than #'>.
    * **previous** _expr_ - on each iteration, _var_ is set to the value _expr_ had at the end of the previous iteration. In the first iteration, since there is no previous value, _var_ is set to `NIL`.
    * **being** _expr_ **&key** (_then_ _expr_) - initializes _var_ to _expr_ and, at the end of each iteration, assigns the result of evaluating _then_ to _var_.
  * **finding** _var_ _condition_ - alternate syntax for **for**, perhaps nicer to read when used in conjunction with **maximizing** and similar operators.
  * **with** **&rest** _bindings_ - establishes bindings as by `let`.
  * **declaring** _fact_ - inserts a declaration at the beginning of the body.
  * **counting** _var_ - same as (**for** _var_ (**from** 0)), i.e., _var_ counts the number of iterations. Note that, due to the order in which the various clauses are evaluated, when the loop terminates regularly, _var_ has a value which is one unit greater than the value _var_ had during the last iteration performed.
  * **generating** _var_ _body_ - like **for**, but lazy; defines a generator rather than an iteration strategy. _body_ can be any form that works with **for**. _var_ is used as in **for**, and additionally gives a name to the generator, which can be used in calls to the **update** macro. If _var_ is a lambda list, each variable in _var_ becomes a name for the generator.

### Termination ###

  * **while** _condition_ - stops the loop when _condition_ evaluates to false.
  * **until** _condition_ - stops the loop when _condition_ evaluates to true.
  * **stop-when** _condition_ - synonym for **until**.

### Collection ###

  * **collecting-into** _var_ **&key** _initially_ _by_ _finally_ - declares _var_ as an accumulation variable, i.e. the possible target of a **collect** (see furher below). _var_ is initially set to _initially_ (`NIL` by default), then to (_by_ _x_ _var_) every time (**collect** _x_ **:into** _var_) is called. At the end of the loop, if _finally_ is not nil, _var_ is set to (funcall _finally_ _var_).
  * **accumulating-to** - alternate name for **collecting-into**.
  * **summing-to** _var_ **&optional** result-processor - special case of **collecting-into** where _initially_ is 0 and _by_ is #'+.

These collection clauses all have a **-and-returning** variant (e.g., **collecting-into-and-returning**) which also causes _var_ to be added to the list of return values of the loop, without the need of an additional (returning _var_) clause.

### Others ###

  * **returning** **&rest** _forms_ - controls the return value(s) of the entire doplus expression. If you specify multiple forms and/or multiple returning clauses, the doplus form will return multiple values, in the order you specified them. Also, **returning** accepts (**values** ...) forms: in that case, each value will contribute to the values returned by the doplus form, just as if you had spelled them directly in the **returning** form.
  * **initially** _form_, **finally** _form_ - initialization and finalization clauses.
  * **options** **&rest** options - provide key-value pairs to configure do+.

## The loop body ##

A block named `NIL` surrounds the whole iteration form, so you can use **return** to terminate the loop returning a value (or zero or many, using **values**). Also, declarations in the body are fully supported.

The loop body is inserted into a **tagbody** form, so you can use labels and GOs (though, of course, GOTO is considered harmful!).

### Collection macros ###

do+ makes available a couple of macros in the lexical environment where the loop body is evaluated. Currently only two collection macros are provided, **collect** and **sum**. They are pretty much equivalent: the accumulation semantics are given by the accumulator declared in the head, not by the collection macro used, so sum mainly exists as syntactic sugar. The only important difference is that **collect** admits a short form where the accumulator variable is not given, in that case a default accumulator is used, and additionally the value of that accumulator is returned as the value of the do+ form if no other return values are specified. This is to address the common pattern `(loop :for x ... :collect (f x))`, that is, `(do+ ((for x ...)) (collect (f x)))`. The long form, instead, is: (**collect**|**sum** _expr_ **:into**|**:to** _var_), where _var_ has to be declared as an accumulation in the head of the do+.

### Iteration control macros ###

These macros can be used inside the body to alter the normal course of the iteration:

  * **skip** **&optional** _loop-name_ will immediately skip to the end of the iteration, without terminating the loop (unless some termination condition evaluates to true, of course).
  * **terminate** **&optional** _loop-name_ will immediately terminate the loop, evaluating finalization clauses and result clauses, and eventually returning one or more values, depending on the result clauses.
  * **update** _generator_ is used to update the variable(s) associated with the given generator. _generator_ must be a symbol that names a generator - that is, one of the variables that can be updated by a generator. **update** returns the value of that variable.
  * **try-update** _generator_ is like **update**, but it doesn't terminate the loop if pre or post conditions are not met, or if errors are signaled when updating the generator.

### Nested loops ###

do+ supports for interacting nested loops. In particular, an inner do+ loop is able to refer to accumulation variables and generators established by an outer do+. For example:

```
(do+ ((for x (in (list 1 2 3)))
      (accumulating-to result)
      (stop-when (> (length result) 10))
      (returning result))
  (do+ ((for y (in (list 'a 'b))))
    (collect (list x y) :into result)))

=> ((1 A) (1 B) (2 A) (2 B) (3 A) (3 B) (4 A) (4 B) (5 A) (5 B) (6 A) (6 B))
```

Also, you can give a name to a loop; if you do that, you'll be able to use that name with the **skip** and **terminate** macros to skip/terminate that loop, even from nested loops. The name of a loop is its first clause, if it is a symbol; or it can be provided by an options clause. Example:

```
(do+ (outer-loop ;;<--this is the name
      ;;alternatively, use (options :name outer-loop)
      (for x (in (list 1 2 3))))
  (print x)
  (do+ ((for k (to 3)))
    (when (> (+ x k) 5)
      (terminate outer-loop))))
```

## Iteration in detail ##

### The algorithm ###

Here is a hopefully detailed description of the general iteration algorithm employed by doplus.

  1. (**binding**) all loop variables are bound to their default values.
  1. (**initialization**) Initialization forms are evaluated. Loop variables are sequentially assigned their initial values. Before/after each assignment, its pre/post condition is evaluated, if specified. If a condition is not met, the loop terminates. Note that, with respect to any other phase of the iteration, initialization is performed atomically (see below).
  1. (**termination check**) termination forms are evaluated in order. As soon as any of them returns true, go to 7.
  1. (**evaluation**) prologue forms are evaluated in order, then the user-supplied body is evaluated as by an implicit **progn**, then epilogue forms are evaluated in order.
  1. (**stepping**) loop variables that have iteration clauses attached are sequentially assigned their next values. Before/after each assignment, its pre/post condition is evaluated, if specified. If a condition is not met, the loop terminates. Note that, with respect to any other phase of the iteration, stepping is performed atomically (see below).
  1. (**loop**) go to 3.
  1. (**finalization**) finalization forms are evaluated in order.
  1. (**return**) return values are computed and returned.

**Note:** in do+, binding and initialization are two very different phases with different semantics. While you can provide a default value for a binding, by design this is done in parallel (as by **let**) so you cannot refer to other variables bound in the same loop. Initialization is the right phase when to assign an initial value to variables; the possibility of giving a default exists only to support type declarations, because if you declare a variable to be, say, a fixnum, you need to initialize it with a fixnum, not NIL.
Also, multiple bindings for the same variable are merged when that makes sense (i.e. when there are no conflicting defaults). This allows idioms such as:

```
(with (x 0))
(declaring (type fixnum x))
(for x (in '(1 2 3)))
```

to work, while for ... in normally produces a binding with no default (making x initially be bound to NIL).

### Initialization and stepping ###

doplus performs initialization and stepping of loop variables sequentially and atomically.

  * sequentially means that each initialization/step form can see the result of assigning the previous variables to the values of their respective initialization/step forms, like in do`*`, as opposed to do. The rationale behind things being as they are is that many higher-level iteration operators need more than one variable to perform their work. Iterate has [something to say about it](http://common-lisp.net/project/iterate/doc/Parallel-Binding-and-Stepping.html#Parallel-Binding-and-Stepping), too.

  * atomically means that all initializations/updates are performed on temporary variables first, and then propagated to the respective loop variables only if they all completed successfully, so that any code outside the initialization/update section will either see all initializations/updates happen, or none of them.

Atomicity is very important and is apparently a feature unique to doplus. Consider the following two iterate forms:

```
(iter
 (for k :in '(a b c d e))
 (for x :in-vector #(1 2 3 4))
 (finally (return (list x k))))
=> (4 E)

(iter
 (for x :in-vector #(1 2 3 4))
 (for k :in '(a b c d e))
 (finally (return (list x k))))
=> (4 D)
```

They only change in the order of the two **for** clauses, yet their return values differ. LOOP behaves the same. This doesn't happen with doplus; the following two forms return the same value:

```
(do+ ((for x (across #(1 2 3 4) :index index))
      (for k (in '(a b c d e)))
      (returning (list x k :index index))))
=> (4 D :INDEX 3)

(do+ ((for k (in '(a b c d e)))
      (for x (across #(1 2 3 4) :index index))
      (returning (list x k :index index))))
=> (4 D :INDEX 3)
```

That happens because as soon as the index goes out of the vector's bounds, the loop is terminated and any updates remain confined in the atomic section, without being visible to the other forms, such as those computing the return values.

If, for performance reasons or other concerns, you want to turn off atomic updates for a certain do+ form, add `(options :atomic-updates nil)` to the clauses of that form.

## Extending doplus ##

Extending doplus is as simple as writing Lisp macros. However, it can be useful to keep in mind a few tips and tricks.

  * **Use defclause**. **defclause** is almost an alias to **defmacro**; but, as an extra, it records the name of the macro in a list (the value of the variable **`*`clauses`*`**) that can be inspected by users and programs to discover known clauses.

  * **Adding new clauses to for, generating** and similar: the only piece of "API" provided by **for** and macros that expand to **for** (such as **generating**, **accumulating** etc. as well as user-defined macros) is that **for**'s body is macroexpanded in a dynamic environment where the variable **`*`iteration-variable`*`** is bound to the first argument to **for**. Note that **`*`iteration-variable`*`** can be a lambda list as well as a symbol; if your macro does not support destructuring, you should nevertheless handle the case when **`*`iteration-variable`*`** is a lambda list by signalling a meaningful error condition.

  * **Preferred macro style**. Generally, macros can expand into a list of clauses, just like you'd write them in the head of a do+ form. For example, a possible implementation of **in-vector** is the following:

```
(defclause in-vector (vector &key (index (gensym "INDEX")))
  "Loops across a vector."
  (let ((tmp-var (gensym "VECTOR")))
    `((with (,tmp-var ,vector))
      (for ,index (from 0 :to (1- (length ,tmp-var)) :by +1))
      (for ,*iteration-variable* (being (aref ,tmp-var ,index))))))
```

> Such a style is to be preferred, but there might be cases where you'll need, or prefer, to use a lower-level API to generate the appropriate clauses. Look at the symbols whose name starts with **make-** (e.g. **make-iteration**) in the **doplus** package. Even if you go to that route, you can still use the higher-level API where it is most convenient, and only plug lower-level calls where strictly necessary. Just for the sake of the example, the code above might be rewritten as:

```
(defclause in-vector (vector &key (index (gensym "INDEX")))
  "Loops across a vector."
  (let ((tmp-var (gensym "VECTOR")))
    `(,(make-binding :var ,tmp-var)
      ,(make-initialization :form `(setf ,tmp-var ,vector))
      (for ,index (from 0 :to (1- (length ,tmp-var)) :by +1))
      (for ,*iteration-variable* (being (aref ,tmp-var ,index))))))
```

  * **Termination tests**. As a general rule, don't use **until**, **stop-when** or similar when writing custom iteration clauses. Instead, explicitly use initialization and step forms, or implicitly use them through pre and post conditions provided by **make-iteration** and **make-simple-iteration**. **until**, **stop-when** etc. create global termination clauses which are unconditionally evaluated at the beginning of each iteration. As such, they do not interact at all with the mechanism of generators. Instead, step forms can be associated with a generator and thus evaluated only when the user calls **update**.

  * **Declarations**. You can instruct doplus to emit declarations for variables you introduce in your own clauses (e.g. to tell the compiler that a given variable acts as a fixnum index). Just add `(`**`declaring`**` `_`some-declaration`_`)` to the list of clauses returned by your macro.