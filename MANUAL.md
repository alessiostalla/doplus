# The doplus (do+) Manual

## Overview

do+ is a high-level, extensible general iteration construct for Common
Lisp, like the built-in LOOP macro and the iterate library.

Unlike LOOP, do+ uses plain Lisp forms to control iteration.

Unlike iterate, do+ does not employ a code walker.

The body of a do+ form consists of clauses that control various aspects of the iteration (which variables are bound, how they are updated, when the loop stops, etc.), intermixed with user code that is executed on each iteration and that can make use of certain specific operators provided by do+.

While it is good practice to put iteration control clauses at the top, and user code at the bottom, do+ doesn't enforce any structure, like LOOP and iterate.

Note that **clauses are macros**. The names of built-in clauses, used throughout
this document, are symbols in the **doplus** package; user-defined
clauses can be defined in other packages as well.

## Types of iteration clauses

doplus accepts the following types of simple clauses:

-   **binding** - specifies a variable to be bound during the loop.
-   **declaration** - inserts a declaration at the beginning of the loop
    body.
-   **initialization** - specifies a form to be evaluated before the
    first iteration.
-   **step** - specifies a form to be evaluated at the end of each
    iteration. Multiple initialization or step clauses will have their
    forms executed in order.
-   **termination** - specifies a condition for terminating the loop,
    that is a form which is evaluated on each iteration and, if it
    returns true, causes the loop to stop. Multiple termination clauses
    are combined by OR.
-   **result form** - specifies a value to be returned as the value of
    the do+ expression when the iteration ends. Multiple result forms
    are combined to multiple return values.
-   **finalization** - specifies a form to be evaluated after the last
    iteration, with loop bindings still in scope. Multiple finalization
    clauses will have their forms executed in order.
-   **accumulation** - detailed below.
-   **prologue**, **epilogue** - forms to be executed respectively
    before and after the loop body, on each iteration. These are
    typically only generated by other complex clauses.
-   **options** - a special clause to control certain advanced aspects
    of the behaviour of the do+ macro.

**Accumulation** deserves a section by itself. An **accumulation**
clause defines a strategy for collecting values into a single result
object; in particular, the strategy consists of:
-   a variable, bound during the lifetime of the loop;
-   a function of two arguments, the current value of the variable and the accumulator, which is used to calculate the next value of the accumulator.

Accumulation clauses are a low-level building block; in user code, they
are generally created by higher-level clauses, along with:
-   an init form, the initial value of the accumulation variable;
-   a result processor, a function to be applied to the accumulator at the end of the loop.

The canonical example, corresponding to `:collect ... :to x` in LOOP,
is represented by an accumulation clause with `x` as the variable,
**cons** as the function, a `NIL` init form, and **nreverse** as the
result processor.

### Composite clauses

Additionally, there are two composite clause types that combine multiple
simple clauses, adding extra semantics:

-   **iteration** - a combination of a number of binding, initialization
    and step forms, some of which can play the special role of pre or
    post conditions (i.e. they are evaluated right before/after proper
    init/step forms and, if they return false, cause the termination of
    the loop). Some examples of high-level clauses that produce
    **iteration** clauses: `(for x (in '(a b c d)))`,
    `(for k (from 0 :to 10))`. Strictly speaking, the clauses that
    compose an iteration need not to be related, although it\'s
    generally meaningful that they are. As a special case, a **simple
    iteration** is an iteration clause with a single variable and with
    at most one init, step, pre and post condition form, and those forms
    are related to that variable. Such a distinction is only important
    at the implementation level, not at the user level - if you\'re not
    extending doplus, you can safely ignore it.
-   **generator** - lazy **iteration**: do+ won\'t automatically update
    the iteration variables at the end of each loop; instead, the user
    can invoke a macro - (**update** *generator-name*) - to explicitly
    perform the update (including checking pre and post conditions and
    terminating the loop if they\'re not met). **Note:** generators are
    **always** initialized eagerly. This is different from iterate where
    you have to call update to compute even the initial value of the
    generator.

## Built-in clauses

The user interface of do+ consists of macros that generate one or more
instances of the clause types discussed in the previous section.
Multiple clauses can be combined in a list.

Here is a list of the clause macros currently supported by do+:

### Iteration

-   **for** *var* *for-body* general iteration clause. *for-body* is a
    Lisp expression generating a doplus clause. *var* is a generally a
    symbol, but certain body forms support destructuring; in those
    cases, *var* can be a lambda list as well (as supported by
    destructuring-bind). The following built-in macros are designed to
    work with **for**:
    -   **in** *seq* **&rest** *args* - *var* is set to each element of
        the sequence on each iteration, and the loop stops when the
        sequence ends. On implementations with extensible sequences
        (ABCL and SBCL), a native sequence iterator is used, and thus
        user-defined sequence types are supported. On other
        implementations, specialized iterators for lists or vectors are
        used. Any provided *args* are passed directly to
        **make-sequence-iterator** (refer to the extensible sequences
        iterator API). **in** supports destructuring.
    -   **in-list** *list* **&key** *by* *rest* - iterates over a list,
        assigning the iteration variable(s) the result of destructuring
        each car in turn. If *rest* is provided, it must name a variable
        to which the remaining cdr of the list will be assigned on each
        iteration. If *by* is provided, it must be a function that,
        given the current list, returns the next cdr to process.
    -   **in-vector** *vector* **&key** *index* - iterates over a
        vector. *index*, if provided, is assigned the current index in
        the vector.
    -   **across** - synonym to **in-vector**.
    -   **from** *expr* **&key** *to* *by* *using* *while* - *var* is
        initially set to expr, then incremented by *by* on each
        iteration. The loop stops when *var* reaches or surpasses *to*.
        *using* and *while* control what \"incremented by\" and
        \"reaches or surpasses\" mean: *using* is the function used to
        increment *var*, by default +. *while* is a function of two
        arguments, applied the current value of *var* and the value of
        *to*: when it returns false, the loop stops. By default, *while*
        is equivalent to \<= (when from \<= to) or \>= (when from \>=
        to).
    -   **to** *expr* **&key** *from* *by* *using* *while* - alternate
        syntax for **from**, by default starting from 0.
    -   **hash-entries-of** *hash-table* - iterates over the entries of
        a hash table. *var* must be in the form (*key* *value*).
    -   **symbols-in** *package-or-packages* **&rest** *symbol-types* -
        iterates over the symbols in one or more packages.
        *symbol-types* must be at least one of **:external**,
        **:internal**, **:inherited**, as per the specification of
        **with-package-iterator**.
    -   **optimizing** *expr* **&key** *test* *saving* *in* - finds the
        optimum value of an expression, testing by default with \#\'\>.
        **optimizing** evaluates *expr* on each iteration. Every time
        the value of *expr* is greater than the one calculated the
        iteration before, *var* is set to the current value of *expr*.
        Additionally, if *saving* and *in* are provided, each variable
        specified in *saving* is stored to the corresponding variable in
        *in*. *saving* and *in* can be either a symbol, or lists of
        symbols of the same length. Example: (**for**
        length-of-longest-x (**optimizing** (length x) **:saving** x
        **:in** longest-x)).
    -   **maximizing** is a synonym for **optimizing**.
    -   **minimizing** is a synonym for **optimizing** except that the
        default test is \#\'\< rather than \#\'\>.
    -   **previous** *expr* - on each iteration, *var* is set to the
        value *expr* had at the end of the previous iteration. In the
        first iteration, since there is no previous value, *var* is set
        to `NIL`.
    -   **being** *expr* **&key** (*then* *expr*) - initializes *var* to
        *expr* and, at the end of each iteration, assigns the result of
        evaluating *then* to *var*.
-   **finding** *var* *condition* - alternate syntax for **for**,
    perhaps nicer to read when used in conjunction with **maximizing**
    and similar operators.
-   **with** **&rest** *bindings* - establishes bindings as by `let`.
-   **declaring** *fact* - inserts a declaration at the beginning of the
    body.
-   **counting** *var* - same as (**for** *var* (**from** 0)), i.e.,
    *var* counts the number of iterations. Note that, due to the order
    in which the various clauses are evaluated, when the loop terminates
    regularly, *var* has a value which is one unit greater than the
    value *var* had during the last iteration performed.
-   **generating** *var* *body* - like **for**, but lazy; defines a
    generator rather than an iteration strategy. *body* can be any form
    that works with **for**. *var* is used as in **for**, and
    additionally gives a name to the generator, which can be used in
    calls to the **update** macro. If *var* is a lambda list, each
    variable in *var* becomes a name for the generator.

### Termination

-   **while** *condition* - stops the loop when *condition* evaluates to
    false.
-   **until** *condition* - stops the loop when *condition* evaluates to
    true.
-   **stop-when** *condition* - synonym for **until**.

### Collection

-   **collecting-into** *var* **&key** *initially* *by* *finally* -
    declares *var* as an accumulation variable, i.e. the possible target
    of a **collect** (see furher below). *var* is initially set to
    *initially* (`NIL` by default), then to (*by* *x* *var*) every time
    (**collect** *x* **:into** *var*) is called. At the end of the loop,
    if *finally* is not nil, *var* is set to (funcall *finally* *var*).
-   **accumulating-to** - alternate name for **collecting-into**.
-   **summing-to** *var* **&optional** result-processor - special case
    of **collecting-into** where *initially* is 0 and *by* is \#\'+.

These collection clauses all have a **-and-returning** variant (e.g.,
**collecting-into-and-returning**) which also causes *var* to be added
to the list of return values of the loop, without the need of an
additional (returning *var*) clause.

### Others

-   **returning** **&rest** *forms* - controls the return value(s) of
    the entire doplus expression. If we specify multiple forms and/or
    multiple returning clauses, the doplus form will return multiple
    values, in the order we specified them. Also, **returning** accepts
    (**values** \...) forms: in that case, each value will contribute to
    the values returned by the doplus form, just as if we had spelled
    them directly in the **returning** form.
-   **initially** *form*, **finally** *form* - initialization and
    finalization clauses.
-   **options** **&rest** options - provide key-value pairs to configure
    do+.

## The loop body

In the body of the loop, besides clauses and user code to be executed, we can use
several macros, detailed below, to alter the course of the loop.

Also, the loop body is inserted into a **tagbody** form, so we can use labels
and GOs (though, of course, GOTO is considered harmful!).

### Collection macros

do+ makes available a couple of macros in the lexical environment where
the loop body is evaluated. Currently only two collection macros are
provided, **collect** and **sum**. They are pretty much equivalent: the
accumulation semantics are given by the accumulator declared in the
head, not by the collection macro used, so sum mainly exists as
syntactic sugar. The only important difference is that **collect**
admits a short form where the accumulator variable is not given, in that
case a default accumulator is used, and additionally the value of that
accumulator is returned as the value of the do+ form if no other return
values are specified. This is to address the common pattern
`(loop :for x ... :collect (f x))`, that is,
`(do+ (for x ...) (collect (f x)))`. The long form, instead, is:
(**collect**\|**sum** *expr* **:into**\|**:to** *var*), where *var* has
to be declared as an accumulation in the head of the do+.

### Iteration control macros

These macros can be used inside the body to alter the normal course of
the iteration:

-   **skip** **&optional** *loop-name* will immediately skip to the end
    of the iteration, without terminating the loop (unless some
    termination condition evaluates to true, of course).
-   **terminate** **&optional** *loop-name* will immediately terminate
    the loop, evaluating finalization clauses and result clauses, and
    eventually returning one or more values, depending on the result
    clauses.
-   **update** *generator* is used to update the variable(s) associated
    with the given generator. *generator* must be a symbol that names a
    generator - that is, one of the variables that can be updated by a
    generator. **update** returns the value of that variable.
-   **try-update** *generator* is like **update**, but it doesn\'t
    terminate the loop if pre or post conditions are not met, or if
    errors are signaled when updating the generator.

### Nested loops

do+ supports for interacting nested loops. In particular, an inner do+
loop is able to refer to accumulation variables and generators
established by an outer do+. For example:

```lisp
(do+
  (for x (in (list 1 2 3)))
  (accumulating-to result)
  (stop-when (\> (length result) 10))
  (returning result)
  (do+
    (for y (in (list \'a \'b)))
    (collect (list x y) :into result)))
=> ((1 A) (1 B) (2 A) (2 B) (3 A) (3 B) (4 A) (4 B) (5 A) (5 B) (6 A)
(6 B))
```

Also, we can give a name to a loop; if we do that, we\'ll be able to
use that name with the **skip** and **terminate** macros to
skip/terminate that loop, even from nested loops. The name of a loop is
its first clause, if it is a symbol; or it can be provided by an options
clause. Example:

```lisp
(do+ outer-loop ;;<--this is the name
                ;;alternatively, use (options :name outer-loop)
  (for x (in (list 1 2 3)))
  (print x)
  (do+
    (for k (to 3))
    (when (> (+ x k) 5)
      (terminate outer-loop))))
```

Also, a block with the same name as the loop name surrounds the whole iteration form, so we can use
**return** to terminate the loop returning a value (or zero or many,
using **values**). Also, declarations in the body are fully supported.

## Iteration in detail

### The algorithm

Here is a hopefully detailed description of the general iteration
algorithm employed by doplus.

1.  (**binding**) all loop variables are bound to their default values.
2.  (**initialization**) Initialization forms are evaluated. Loop
    variables are sequentially assigned their initial values.
    Before/after each assignment, its pre/post condition is evaluated,
    if specified. If a condition is not met, the loop terminates. Note
    that, with respect to any other phase of the iteration,
    initialization is performed atomically (see below).
3.  (**termination check**) termination forms are evaluated in order. As
    soon as any of them returns true, go to 7.
4.  (**evaluation**) prologue forms are evaluated in order, then the
    user-supplied body is evaluated as by an implicit **progn**, then
    epilogue forms are evaluated in order.
5.  (**stepping**) loop variables that have iteration clauses attached
    are sequentially assigned their next values. Before/after each
    assignment, its pre/post condition is evaluated, if specified. If a
    condition is not met, the loop terminates. Note that, with respect
    to any other phase of the iteration, stepping is performed
    atomically (see below).
6.  (**loop**) go to 3.
7.  (**finalization**) finalization forms are evaluated in order.
8.  (**return**) return values are computed and returned.

**Note:** in do+, binding and initialization are two very different
phases with different semantics. While we can provide a default value
for a binding, by design this is done in parallel (as by **let**), so we
cannot refer to other variables bound in the same loop. Initialization
is the right phase when to assign an initial value to variables; the
possibility of giving a default exists only to support type
declarations, because if we declare a variable to be, say, a fixnum,
we need to initialize it with a fixnum, not NIL. Also, multiple
bindings for the same variable are merged when that makes sense (i.e.
when there are no conflicting defaults). This allows idioms such as:

```lisp
(with (x 0))
(declaring (type fixnum x))
(for x (in '(1 2 3)))
```

to work, while `for \... in` normally produces a binding with no default
(making `x` initially bound to `NIL`).

### Initialization and stepping

doplus performs initialization and stepping of loop variables
sequentially and atomically.

-   sequentially means that each initialization/step form can see the
    result of assigning the previous variables to the values of their
    respective initialization/step forms, like in do`*`, as opposed to
    do. The rationale behind things being as they are is that many
    higher-level iteration operators need more than one variable to
    perform their work. Iterate has [something to say about
    it](http://common-lisp.net/project/iterate/doc/Parallel-Binding-and-Stepping.html#Parallel-Binding-and-Stepping),
    too.

-   atomically means that all initializations/updates are performed on
    temporary variables first, and then propagated to the respective
    loop variables only if they all completed successfully, so that any
    code outside the initialization/update section will either see all
    initializations/updates happen, or none of them.

Atomicity is very important and is apparently a feature unique to
doplus. Consider the following two iterate forms:

```lisp
(iter (for k :in '(a b c d e))
      (for x :in-vector #(1 2 3 4))
      (finally (return (list x k))))
=> (4 E)

(iter (for x :in-vector #(1 2 3 4))
      (for k :in '(a b c d e))
      (finally (return (list x k))))
=> (4 D)
```

They only change in the order of the two **for** clauses, yet their
return values differ. LOOP behaves the same. This doesn\'t happen with
doplus; the following two forms return the same value:

```lisp
(do+
  (for x (across #(1 2 3 4) :index index))
  (for k (in '(a b c d e)))
  (returning (list x k :index index)))
=> (4 D :INDEX 3)

(do+
  (for k (in '(a b c d e)))
  (for x (across \#(1 2 3 4) :index index))
  (returning (list x k :index index)))
=> (4 D :INDEX 3)
```

That happens because as soon as the index goes out of the vector\'s
bounds, the loop is terminated and any updates remain confined in the
atomic section, without being visible to the other forms, such as those
computing the return values.

If, for performance reasons or other concerns, you want to turn off
atomic updates for a certain do+ form,
add `(options :atomic-updates nil)` to the clauses of that form.

## Extending doplus

Extending doplus is as simple as writing Lisp macros. However, it can be
useful to keep in mind a few tips and tricks.

-   **Use defclause**. **defclause** is almost an alias to **defmacro**;
    but, as an extra, it records the name of the macro in a list (the
    value of the variable **`*`clauses`*`**) that can be inspected by
    users and programs to discover known clauses.

-   **Adding new clauses to for, generating** and similar: the only
    piece of \"API\" provided by **for** and macros that expand to
    **for** (such as **generating**, **accumulating** etc. as well as
    user-defined macros) is that **for**\'s body is macroexpanded in a
    dynamic environment where the variable **`*`iteration-variable`*`**
    is bound to the first argument to **for**. Note that
    **`*`iteration-variable`*`** can be a lambda list as well as a
    symbol; if our macro does not support destructuring, we should
    nevertheless handle the case when **`*`iteration-variable`*`** is a
    lambda list by signalling a meaningful error condition.

-   **Preferred macro style**. Generally, macros can expand into a list
    of clauses, just like we\'d write them in the head of a do+ form.
    For example, a possible implementation of **in-vector** is the
    following:

```lisp
(defclause in-vector (vector &key (index (gensym "INDEX")))
  "Loops across a vector."
  (let ((tmp-var (gensym "VECTOR")))
    `((with (,tmp-var ,vector))
      (for ,index (from 0 :to (1- (length ,tmp-var)) :by +1))
      (for ,*iteration-variable* (being (aref ,tmp-var ,index))))))
```

Such a style is to be preferred, but there might be cases where
we\'ll need, or prefer, to use a lower-level API to generate the
appropriate clauses. Look at the symbols whose name starts with
**make-** (e.g. **make-iteration**) in the **doplus** package. Even if
we go to that route, we can still use the higher-level API where it
is most convenient, and only plug lower-level calls where strictly
necessary. Just for the sake of the example, the code above might be
rewritten as:

```lisp
(defclause in-vector (vector &key (index (gensym "INDEX")))
  "Loops across a vector."
  (let ((tmp-var (gensym "VECTOR")))
    `(,(make-binding :var ,tmp-var)
      ,(make-initialization :form `(setf ,tmp-var ,vector))
      (for ,index (from 0 :to (1- (length ,tmp-var)) :by +1))
      (for ,*iteration-variable* (being (aref ,tmp-var ,index))))))
```

-   **Termination tests**. As a general rule, don\'t use **until**,
    **stop-when** or similar to implement custom iteration clauses.
    Instead, explicitly use initialization and step forms, or implicitly
    use them through pre and post conditions provided by
    **make-iteration** and **make-simple-iteration**. **until**,
    **stop-when** etc. create global termination clauses which are
    unconditionally evaluated at the beginning of each iteration. As
    such, they do not interact at all with the mechanism of generators.
    Instead, step forms can be associated with a generator and thus
    evaluated only when the user calls **update**.

-   **Declarations**. We can instruct doplus to emit declarations for
    variables we introduce in our own clauses (e.g. to tell the
    compiler that a given variable acts as a fixnum index). Just add
    `(declaring some-declaration)` to the list of clauses
    returned by our macro.
